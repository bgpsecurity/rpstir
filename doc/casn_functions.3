

CASN Functions (3)          ASN.1 LIBRARY FUNCTIONS   CASN Functions (3)



NAME
        clear_casn, copy_casn, decode_casn, delete_casn, diff_casn,
        diff_casn_num, diff_casn_time, dump, dump_size, eject_casn, encode_casn,
        encodesize_casn, get_casn_file, index_casn, inject_casn, insert_casn,
        member_casn, next_of, num_items, put_casn_file,
        read_casn, read_casn_bit, read_casn_bits,
        read_casn_double, read_casn_num, read_casn_time, read_objid,
        read_vsize_casn, readvsize_objid, remove_casn,
        simple_constructor, size_casn,
        tagged_constructor, tag_casn, vsize_casn,
        vsize_objid, write_casn, write_casn_bit, write_casn_bits,
        write_casn_double, write_casn_num, write_casn_time, write_objid

SYNOPSIS

        #include "casn.h"

    Constructors and Destructors

        void simple_constructor(struct casn *casnp, unsigned short level,
            int type)

        void tagged_constructor(struct casn *casnp, unsigned short level,
            int type, int tag)

        void delete_casn(struct casn *casnp)

        void clear_casn(struct casn *casnp, unsigned short mask)

    Decoding and Encoding

        int decode_casn(struct casn *casnp, unsigned char *from, long size)

        int decode_casn_lth(struct casn *casnp, unsigned char *from)

        int encode_casn(struct casn *casnp, unsigned char *to)

        int size_casn(struct casn *casnp)

        int encodesize_casn(struct casn *casnp, unsigned char **pp)

    Writing and Reading

        int write_casn(struct casn *casnp, unsigned char *from, int lth)

        int read_casn(struct casn *casnp, unsigned char *to)

        int vsize_casn(struct casn *casnp)

        int readvsize_casn(struct casn *casnp, unsigned char **pp)

    Special Writing and Reading

Apr 20 2006                       1 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        int write_casn_num(struct casn *casnp, int val)

        int read_casn_num(struct casn *casnp, long *to)

        int write_casn_time(struct casn *casnp, unsigned long)

        int read_casn_time(struct casn *casnp, unsigned long *to)

        int write_objid(struct casn *casnp, char *from)

        int read_objid(struct casn *casnp, char *)

        int vsize_objid(struct casn *casnp)

        int readvsize_objid(struct casn *casnp, char **pp)

        int write_casn_bits(struct casn *casnp, unsigned char *from,
            unsigned long lth, int shift)

        int read_casn_bits(struct casn *casnp, unsigned char *to,
            unsigned char *shift)

        int write_casn_bit(struct casn *casnp, int val)

        int read_casn_bit(struct casn *casnp)

        int write_casn_double(struct casn *casnp, double val)

        int read_casn_double(struct casn *casnp, double *valp)

    CHOICE Functions

        int tag_casn(struct casn *casnp)

    Array (OF) Functions

        int num_items(struct casn *casnp)

        struct casn *next_of(struct casn *casnp)

        struct casn *inject_casn(struct casn *casnp, int index)

        int eject_casn(struct casn *casnp, int index)

        struct casn *member_casn(struct casn *casnp, int index)

        struct casn *insert_casn (struct casn *casnp, int index)

        int remove_casn(struct casn *, int index)

        struct casn *index_casn(struct casn *casnp, int index)




Apr 20 2006                       2 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 



    Comparison Functions

        int diff_casn(struct casn *casnp1, struct casn *casnp2)

        int diff_casn_num(struct casn *casnp1, long val)

        int diff_casn_time(struct casn *casnp1, struct casn *casnp2)

    Other Functions

        int copy_casn(struct casn *to_casnp, struct casn *from_casnp)

        int get_casn_file(struct casn *casnp, char *filename, int fildes)

        int put_casn_file(struct casn *casnp, char *filename, int fildes)

        int dump_casn(struct casn *casnp, char *to)

        int dump_size(struct casn *casnp)


DESCRIPTION

        These functions implement a 'C' language approach to ASN.1-encoded data.
        The   instructions  in  casn_gen(1)  describe  an  application  program,
        casn_gen,  that  translates  descriptions  of  items  from   the   ASN.1
        specification  language  into C source code and header files appropriate
        for use with these routines.  These routines provide access to  all  the
        components  of  an ASN.1-encoded item so that such items may be decoded,
        analyzed and modified, or may be constructed and encoded.

        The instructions below are divided into sections  corresponding  to  the
        grouping of the functions in the list above.


    Constructors and Destructors

        void simple_constructor(struct casn *casnp, unsigned short level,
            int type)

        void tagged_constructor(struct casn *casnp, unsigned short level,
            int type, int tag)

        void delete_casn(struct casn *casnp)

        void clear_casn(struct casn *casnp, unsigned short mask)

        Whenever an  object  is  declared,  as  described  in  casn_gen(1),  its
        constructor  must  be  called  before  the  object can be used.  For all
        constructed objects the source code for their constructors is  generated
        by  casn_gen.  A constructor always has the same name as the ASN.1 class
        name.  For example, suppose that an ASN.1 object is defined as shown  in
        Figure  1  and  that  this specification is translated with casn_gen and

Apr 20 2006                       3 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        compiled.  If a programmer then declares a Body object, e.g.

            Body body;

        this creates an instance of  such  an  object  without  any  data.   Its
        constructor must be called like this:

            Body((struct casn *)&body, (unsigned short)0);

        to initialize it.  The Body constructor calls all the lower constructors
        that  it  needs.   The  top constructor should always be called with the
        value 0 in the unsigned short.

        Two  constructors  are  provided  in  the   library   for   constructing
        free-standing  primitive  objects, i.e. objects that have no members and
        are not members of another object.   The  'simple_constructor'  must  be
        used whenever a primitive object has the tag of its type, e.g.

            Number ::= INTEGER

        which is the usual case.  The 'tagged_constructor' must be used  if  the
        object is defined with a tag such as

            Number ::= [0] INTEGER

        The level should always be zero.  If a primitive  object  is  explicitly
        tagged,  then  the  call to the tagged constructor must be followed by a
        statement to set a flag, such as

            tagged_constructor(&number, 0, ASN_INTEGER, 0x80);
            number.flags |= ASN_EXPLICIT_FLAG;

        If any  object  is  declared  as  an  automatic  variable,  the  general
        destructor,  'delete_casn'  must be called before exiting the routine in
        which the object was declared, in order to free memory allocations  made
        when  using  the  object.   (In C++ this is handled automatically by the
        compiler, but it must be done explicitly in C.)

        The 'clear_casn' function may be called to clear out the contents of any
        object  that  has been decoded or otherwise filled in.  It does not free
        up all the memory that 'delete_casn' does.  It is automatically  invoked
        by  any  'decode_casn' or 'write_casn' function (see below) to clear out
        space before re-filling it.  When applied to an 'OF' object (see below),
        it removes all members of the 'OF'. <<NEED TEXT: commentary that the 'OF' object becomes uninitialized, not just zero-length.  Also any CHOICE/DEFINED BY also becomes unititialized.>>


    Accessing Members

        After the constructor has been called, the functions described below can
        then  be  invoked  with  a  pointer  to  the desired item in the usual C
        notation for nested structures.  Every constructed  item  has  a  member
        named 'self' in addition to the members named in its definition.  In the
        example in Figure 1, one could refer to:


Apr 20 2006                       4 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


            body.self

        or

            body.head.hair.brown

        or

            body.arms.left.self

        One may also define pointers to operate on internal members of  objects,
        e.g. if one declares

            Arms *armsp = &body.arms;

        then that pointer may be used in the standard C fashion, such as

            armsp->left.self

        or

            armsp->left.forearm


    Decoding and Encoding

        int decode_casn(struct casn *casnp, unsigned char *from, long size)

        int decode_casn_lth(struct casn *casnp, unsigned char *from)

        int encode_casn(struct casn *casnp, unsigned char *to)

        int size_casn(struct casn *casnp)

        int encodesize_casn(struct casn *casnp, unsigned char **pp)

        An array, or stream, of ASN.1-encoded material can be decoded and placed
        in  the  appropriate  object by invoking one of the decode functions for
        the desired object, e.g.

            decode_casn((struct casn *)&body, from, size);

        where 'from' points to an ASN.1-encoded stream and 'size' is the  number
        of  bytes  in  that  stream.   If  the  size  is not known, the function
        'decode_casn_lth' may be used, but  this  has  less  protection  against
        invalid length fields within the stream.  The decode functions cause the
        object to be filled in with the data in the stream.  Any item  which  is
        defined  in  the  object but is not present in the incoming stream is an
        error unless it was defined as OPTIONAL in the object.  In that case  it
        is  simply skipped over and not marked as filled in.  If the decoding is
        successful, the functions return a count of the bytes decoded.  If there
        is  any  error, either because the stream has an ASN.1 encoding error or
        the stream does not  match  the  object,  the  number  returned  is  the
        negative  of  the  offset  of  the  offending byte, The decode functions

Apr 20 2006                       5 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        always clear out and free all  old  data  before  beginning  the  actual
        decoding.

        The decoding process can be reversed using  the  encode  function,  like
        this:

            encode_casn((struct casn *)&body, to);

        where 'to' is a pointer to where the ASN.1-encoded result is to be  put.
        It  returns a count of the bytes it put into 'to'.  The space needed for
        such a result can be determined beforehand by the size function:

            size_casn((struct casn *)*body);

        If the encode call encounters no error, it returns the same value as the
        'size_casn'  call.   If  an item is encountered that has not been filled
        in, one of two things happens: If  the  item  is  OPTIONAL  or  has  its
        DEFAULT  value, it is skipped over, otherwise the negative of the number
        of bytes encoded so far is returned.  CAUTIONARY NOTE: The  question  of
        whether  an  'empty'  item  is skipped over or returns a negative number
        depends on the optional nature of each item.  See below for  SET  OF  or
        SEQUENCE  OF  objects.   See  also Diagnostics below for further help in
        determining where the error occurred.

        The function 'encodesize_casn' does a 'size_casn'  operation,  'callocs'
        appropriate  space  and  encodes  the  object pointed to by 'casnp'.  It
        returns the size of the encoding operation with the address of  the  new
        space  in  'pp'.   If  the 'size_casn' fails, the return is negative and
        'pp' is null.

        Note that the encode and size functions always follow the  Distinguished
        Encoding  Rules  (DER), but the decode functions accept anything encoded
        under the Basic Encoding Rules (BER).

        Refer to Appendix A for details of  decoding  and  encoding  DEFINED  BY
        objects.

    Writing and Reading

        int write_casn(struct casn *casnp, unsigned char *from, int lth)

        int read_casn(struct casn *casnp, unsigned char *to)

        int vsize_casn(struct casn *casnp)

        int readvsize_casn(struct casn *casnp, unsigned char **pp)

        Note that the ASN.1 library follows this convention:
         - write: to struct, from byte stream or other type
         - read: from struct, to byte stream or other type

        These functions perform operations similar to the decoding and  encoding
        functions  but  with  an  important  difference  that  must  be  clearly
        understood:  Each ASN.1 item contains a tag field, a length field and  a
        value field in that order.  All three fields make up what is referred to
        herein as an ASN.1 stream.  'Write_casn', 'read_casn'  and  'vsize_casn'
        deal only with the values.  Whereas the call


Apr 20 2006                       6 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


            decode_casn(&body.trunk.self, from, size)

        assumes that 'from' points to the tag of a stream containing 'trunk',
        the call

            write_casn(&body.trunk.self, from, lth)

        assumes that 'from' points to just the value of a 'trunk' without the
        tag and length.  The call

            read_casn(&body.arms.self, to)

        puts the value of 'arms', that is, the stream of 'arms.left' followed by
        the  stream  of  'arms.right'.   Note  that  the object specified may be
        either a primitive one or a constructed one.

        The 'write_casn' function can be used to change a value  in  an  object.
        If  the  object  is constructed, the array pointed to by 'from' (and the
        corresponding 'lth') must  contain  streams  of  all  the  ASN.1-encoded
        objects.   Whenever  'write_casn'  or  'decode_casn'  is used to fill an
        object, all directly 'higher' objects are marked as filled in, e.g.

            write_casn((struct casn *)&body.arms.left, from, lth)

        marks 'body' and 'body.arms' as filled in.  Any prior data in the object
        being written is cleared out before the writing starts.

        A NULL object may be filled in with a 'write_casn' function call  having
        a value of zero for 'lth'.

        The writing function returns a count of the bytes it  wrote,  unless  it
        encounters  any  error.   In  that  case  it returns the negative of the
        offset to the offending byte.

        Any writing to a definer, that is, an OBJECT IDENTIFIER  or  an  INTEGER
        that  defines  one  or more later DEFINED BY objects automatically marks
        the chosen defined object(s) and clears out the ones  not  chosen.   See
        Appendix A for details.

        The value returned by  the  'read_casn'  function  or  the  'vsize_casn'
        function  is  a count of the bytes that are, or would be, put into 'to'.
        If the addressed item or some part of it has not been filled  in,  there
        are  three possibilities: for an OPTIONAL item, zero is returned; for an
        item having a DEFAULT value,  the  size  of  the  default  is  returned;
        otherwise  -1  is returned.  If 'read_casn' returns a value greater than
        zero, that may bytes are copied into 'to'.   See  also  the  note  below
        about  encoding  SET  OF  and  SEQUENCE  OF  objects  and  refer  to the
        Diagnostics section  below  for  help  in  determining  where  an  error
        occurred.   A SEQUENCE or SET with a default '{}' is read as empty if it
        has not been filled in, that is, nothing is put into 'to'  and  zero  is
        returned.

        The function 'vsize_casn' returns a count of the bytes that  a  call  to
        'read_casn' will return.  The 'vsize_casn' function is the preferred way

Apr 20 2006                       7 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        to determine if an object has been filled in.  If  it  returns  a  value
        greater  than zero, the object has been filled in, otherwise it has not,
        unless it is a NULL item.  The 'vsize_casn' function always returns zero
        for  a NULL item; use 'size_casn' to determine if a NULL has been filled
        in.

        The function 'readvsize_casn' does a 'vsize_casn'  operation,  'callocs'
        appropriate  space  and  reads  the  object  pointed  to by 'casnp'.  It
        returns the size of the reading operation with the address  of  the  new
        space  in  'pp'.   If the 'vsize_casn' fails, the return is negative and
        'pp' is null.


    Special Writing and Reading Functions

        int write_casn_num(struct casn *casnp, int val)

        int read_casn_num(struct casn *casnp, long *to)

        int write_casn_time(struct casn *casnp, unsigned long)

        int read_casn_time(struct casn *casnp, unsigned long *to)

        int write_objid(struct casn *casnp, char *from)

        int read_objid(struct casn *casnp, char *)

        int vsize_objid(struct casn *casnp)

        int readvsize_objid(struct casn *casnp, char **pp)

        int write_casn_bits(struct casn *casnp, unsigned char *from,
            unsigned long lth, int shift)

        int read_casn_bits(struct casn *casnp, unsigned char *to,
            unsigned char *shift)

        int write_casn_bit(struct casn *casnp, int val)

        int read_casn_bit(struct casn *casnp)

        int write_casn_double(struct casn *casnp, double val)

        int read_casn_double(struct casn *casnp, double *valp)

        These functions are provided for convenience  in  converting  the  ASN.1
        representation  of  values to or from formats more useful for computing.
        The 'write_casn_num' function writes a 'long' integer  into  an  object;
        the  'read_casn_num'  function does the inverse.  Both return the number
        of bytes in the value,  or,  if  there  is  an  error,  -1.   Note  that
        'read_casn_num' follows the same rules as 'read_casn' for items having a
        DEFAULT.  These functions return -1  if  attempted  on  anything  but  a
        BOOLEAN, ENUMERATED or INTEGER object.


Apr 20 2006                       8 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        'Write_casn_time' does a similar thing  with  an  unsigned  long  number
        representing  the number of seconds since the start of 1970 in Greenwich
        Mean Time, and 'read_casn_time' does the inverse.  These  functions  may
        be  used  only  with UTCTime or GeneralizedTime.  Note that the decoding
        functions and the  'write_casn'  function  check  the  validity  of  any
        character string that is written to a time object and return an error if
        the string does not represent a valid time or the object is not  a  time
        object.

        The 'objid'  functions  convert  from  and  to  the  human-readable  dot
        notation used for object identifiers, e.g. "1.2.3.4".  The 'write_objid'
        function converts  from  dot  notation  and  returns  the  size  of  the
        converted  value.   The function 'read_objid' converts from dot notation
        and returns the size of the resulting string.  'vsize_objid' reports how
        many    characters    'read_objid'    will    return.     The   function
        'readvsize_objid' combines 'vsize_objid', a  'calloc'  operation  and  a
        'read_objid'  to  obtain the value in dot notation, the address of which
        is put into 'pp'.  These return -1  if  the  object  is  not  an  OBJECT
        IDENTIFIER.  <<NEED TEXT: write_objid will often have the side-effect of causing a CHOICE to be made in a 'DEFINED BY'.  Actually, things can be DEFINED BY anything else, not just OID, but OID is the most common.  Also, please mention diff_objid because it will be used frequently.>>

        The special 'bits' functions are valid only for BIT STRINGs;  any  other
        use  returns  -1.  If the object does not have named bits, it is assumed
        to  be  a  left-justified  number.   In  that   case,   'read_casn_bits'
        right-justifies  the  string to line up on byte boundaries, putting into
        the 'shift' parameter a count of the number of bits by which the  string
        had  to  be  shifted  to  the  right.  Objects having named bits are not
        shifted in this fashion; 'shift' is given the value zero.  This function
        returns  a count of the bytes put into 'to'.  'Write_casn_bits' does the
        inverse.

        For BIT STRINGs with named bits  the  'bit'  functions  allow  accessing
        specific bits, e.g.

            read_casn_bit(&body.arms.left.hand.fingers.thumb)

        returns the value of the 'thumb' bit alone as either a zero  or  a  one.
        Similarly,  the  'write_casn_bit'  function clears or sets an individual
        bit depending of whether the 'val' parameter is zero or non-zero.  These
        functions  return -1 if called for objects which are not part of a named
        BIT STRING.

        The function 'read_casn_double' reads into a double and  returns  a  one
        unless  the  contents  have  one  of the special values PLUS-INFINITY or
        MINUS-INFINITY.  In those cases it returns the value -ASN_BOUNDS_ERR and
        puts  into the double either +1 or -1, depending on whether the infinity
        is positive or negative.  NOTE: The code  in  casn_real.c  is  currently
        written  for  a  Sparc, and it must be compiled with a '-DSPARC' switch.
        For  other  platforms  the  '#defines'  must  be  changed  to  suit  the
        representation  of  floating  point  numbers  on  those  platforms.  The
        definitions  there  are  believed  to  be  elaborate  enough  for  other
        platforms.

        The function to write floating point numbers allows  the  base  for  the
        exponent  to be specified as either 2, or 10.  It returns a count of the

Apr 20 2006                       9 

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        bytes written into the object.  Although bases 8, 16 and NR1 and NR2  in
        ISO 6093 are described in the ASN.1 specifications, they are not allowed
        when writing because they do not conform to the  Distinguished  Encoding
        Rules.  Note, however, that these other bases are accepted when decoding
        material.  Such material is converted to base 2 (if it was base 8 or 16)
        or to base 10 (if it was NR1 or NR2) when encoded.  To write positive or
        negative infinity, the base must be either +1 or  -1  respectively.   In
        those cases the value of 'from' is irrelevant.

        Certain ASN.1 objects (ENUMERATEDs and INTEGERs  or  OBJECT  IDENTIFIERs
        with  defined  values)  permit  an  additional level of addressing.  For
        example

            read_casn_num(&eye.blue, to)

        examines the 'eye' object to see if it has the 'blue' value.  If so, its
        value  is  put  into  'to' and a count is returned, just as if 'eye' had
        been read.  If the value of 'eye' is something else, zero is returned.

    CHOICE Functions

        int tag_casn(struct casn *casnp)

        An object which is defined as a CHOICE can be  read  at  either  of  two
        levels, e.g. either as the CHOICE itself:

            read_casn((struct casn *)&body.head.hair, to)

        or as a member of the CHOICE:

            read_casn((struct casn *)&body.head.hair.black, to)

        In the first case the value obtained is that of whatever item  has  been
        filled in; in the second case the result is similar to that of a defined
        ENUMERATED explained above, i.e. it depends on  whether  that  item  was
        filled in or not.

        The 'tag_casn' function permits the programmer to determine which member
        of  a CHOICE (or which case for an ANY)  was chosen.  It returns the tag
        value if there is no error.  If the specified member has not been filled
        in, or no member of a CHOICE has been filled in, it returns 0;

        When writing to a CHOICE, the 'write_casn'  function  must  address  the
        specific choice desired, e.g.

            write_casn((struct casn *)&body.head.hair.brown, from, lth)

        except  that  if  the  choice  is  among   just   a   NumericString,   a
        PrintableString  or  a  T61String,  the  function  will  find  the  most
        restrictive type.  Any 'write_casn' to  a  specific  choice  where  that
        choice  is  a NumericString, PrintableString or T61String is checked for
        validity, returning the negative of the offset to the offending byte  if
        an error is found.


Apr 20 2006                       10

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        Writing to a particular object within a  CHOICE clears all the choices.

        See  also  the  description  below  of  the  conversion  and  comparison
        functions for other ways to obtain or test the contents of certain types
        of objects.


    Array (OF) Functions

        int num_items(struct casn *casnp)

        struct casn *next_of(struct *casnp)

        int inject_casn(struct casn *casnp, int index)

        int eject_casn(struct casn *casnp, int index)

        struct casn *member_casn(struct casn *casnp, int index)

        struct casn *insert_casn (struct casn *casnp, int index)

        int remove_casn(struct casn *, int index)

        struct casn *index_casn(struct casn *casnp, int index)

        Items which are members of a SEQUENCE OF or a SET OF can be  thought  of
        as  parts  of  something like an array of unspecified size.  The current
        size of the array is found with the 'num_items' function, e.g.

            i = num_items(&body.legs.self)

        and then an individual member is accessed with  with  the  'member_casn'
        function:

            struct Leg *legp = member_casn(&body.legs, 1);

        which corresponds to member [1] of the array.   A  primitive  object  is
        always  a  simple  'struct casn', so you can create a pointer to such an
        object, e.g.

            struct casn *eyp = member_casn(&body.head.eyes, 0)

        Any attempt to invoke the 'member_casn' function for  an  object  beyond
        the  end  of  a  SET  OF  or SEQUENCE OF array is an error which will be
        reported as soon as there is any attempt to use that member.

        The function  'next_of'  allows  one  to  move  sequentially  through  a
        SET/SEQUENCE  OF.   The  parameter  'casnp'  provides the address of the
        starting item.  If there is  another  member,  the  function  returns  a
        pointer  to  it.   If not, it returns a null pointer.  Any attempt to go
        beyond the last returns a null pointer and prints an error message.  Any
        attempt  to  use this function on something other than an 'OF' returns a
        negative number.


Apr 20 2006                       11

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        If a SET OF or a SEQUENCE OF is empty, the value returned by 'size_casn'
        and 'encode_casn' depends on whether the SET or SEQUENCE was declared to
        have a minimum size.  If it was declared to have a minimum size of  zero
        or  was  not  declared  to  have any minimum size, then the empty SET or
        SEQUENCE is permissible and a number greater than zero (usually 2)  will
        be  returned, but if a minimum size greater than zero was declared, then
        a negative number will be returned indicating that the  object  was  not
        filled in.

        The functions 'inject_casn' and  'eject_casn'  may  be  used  only  with
        objects which are 'SET OF' or 'SEQUENCE OF' objects.  'Inject_casn' adds
        an  object  just  before  the  specified  index  into  the  array,  i.e.
        'inject(0)'   inserts   at   the   start.   In  the  example  above,  if
        body.legs.member(0) has been filled in, then

            inject_casn(&body.legs.self, 0);

        moves the former object at index 0 to index 1 and makes an empty one  at
        index  0.  If the index is equal to the present size of the array, a new
        object is created at the 'end' of the array.  If  the  index  is  larger
        than  the  size of the array or is negative, a null pointer is returned,
        and an error is reported.

        The 'eject_casn' function does the opposite of 'inject_casn'  by  taking
        out  the  designated   object  in the array and shrinking the array.  It
        returns the index of the designated object.  If there is any error, such
        as  an  index beyond the current end of the array, -1 is returned and an
        error is reported.

        If either 'inject' or 'eject' is used  on  an  object  which  is  not  a
        SET/SEQUENCE  OF, a run-time error is reported and either a null pointer
        or a negative number is returned.

        The functions 'index_casn', 'insert_casn' and 'remove_casn' are an older
        form of the functions 'member_casn', 'inject_casn' and 'eject_casn'.  In
        each of these functions the 'struct casn  *'  parameter  refers  to  the
        member of the array, not to the array.  For example, these two calls are
        equivalent:

            struct Leg *legp = member_casn(&body.legs, 1);

        and

            struct Leg *legp = index_casn(&body.legs.leg, 1);

        Use of these functions has often  proved  confusing,  so  their  use  is
        deprecated.

        Be careful, too, in setting pointers to objects in 'OF' arrays that  the
        pointer  is set after the array has been established.  In particular, it
        is an error to do

            count = num_items(&body.legs.self);
            legp = member_casn(&body.legs.self, count);

Apr 20 2006                       12

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


            inject_casn(&body.legs.self, count);

        After the injection 'legp' will point to same one it did
        before, which is now the the one at member(count+1).  <<NEED
        TEXT: We need an eject_all_casn to clear sequence of and set
        of data with a zero-length.>>

    Comparison Functions

        int diff_casn(struct casn *casnp1, struct casn *casnp2)

        int diff_casn_num(struct casn *casnp1, long val)

        int diff_casn_time(struct casn *casnp1, struct casn *casnp2)

        The function 'diff_casn' compares the first object  to  the  second  and
        returns  one  of  four  values: 1 if the first object is larger than the
        second, 0 if the two objects are  equal,  -1  if  the  first  object  is
        smaller  than the second, -2 if the comparison is invalid for any reason
        (e.g. one of the objects has not been filled in, or the two objects  are
        not  of  the same type).  The rules for size comparison are:  If the two
        objects are INTEGERs, they are compared as signed numbers.  If  the  two
        objects  are  ENUMERATEDs  or  BOOLEANs,  they  are compared as unsigned
        numbers.  All other primitive objects  are  compared  as  left-justified
        strings.    Comparison  of  constructed  objects  proceeds  recursively,
        comparing tags, checking that both objects  have  been  filled  in,  and
        testing  primitive objects.  Note that the tags at the highest level are
        not compared, but that the lower-level tags are.  At the highest  level,
        therefore, only values are compsred.

        The function 'diff_casn_time' compares two  UTCTime  or  GeneralizedTime
        objects.   It  calculates  the correct absolute time appropriate to each
        object and compares the two values.  Times may thus be compared  without
        regard  for time zones or the type of encoding.  If either object is not
        a time object, -2 is returned.

        The function 'diff_casn_num' compares the contents of the object pointed
        to by 'casnp' to the value in 'val'.  An INTEGER is compared as a signed
        number, an ENUMERATED is  compared  as  unsigned,  and  any  others  are
        rejected with a return of -2.

    Other Functions

        int copy_casn(struct casn *to_casnp, struct casn *from_casnp)

        int get_casn_file(struct casn *casnp, char *filename, int fildes)

        int put_casn_file(struct casn *casnp, char *filename, int fildes)

        int dump_casn(struct casn *casnp, char *to)

        int dump_size(struct casn *casnp)

        The 'copy_casn' function copies the object 'from_casnp'  to  the  object
        'to_casnp',   proceeding  recursively  and  actually  copying  only  the
        primitive items.  There are  three  possible  returns:  -1  if  the  two

Apr 20 2006                       13

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        objects  do not match, zero if the source object has not been filled in,
        or a number greater than zero if the copy succeeds.  Note that the  tags
        at  the  highest  level  are  disregarded.  Be careful when copying to a
        CHOICE object to specify the choice, as  required  for  a  'write_casn'.
        This  is  an  easy mistake to make, because the object being copied from
        can be read equally well at the CHOICE level or at the chosen level,  as
        explained above.

        The  functions  'get_casn_file  and  'put_casn_file'  are   higher-level
        functions  to  allow  direct  transfers between files and ASN.1 objects.
        The 'get_casn_file' function combines the reading and decoding of a file
        that  contains  an  ASN.1-encoded  stream.   If  the  'name'  pointer is
        non-null, the named file is opened, otherwise the value of  'fildes'  is
        taken  to  be  the  file  descriptor  of a file that has been opened for
        reading, e.g. zero for standard input.  These report an error  if  there
        are additional bytes in the file beyond the ASN.1 stream.

        The  'put_casn_file'  function  combines   encoding   and   writing   an
        ASN.1-encoded  stream  to a file, which can be defined either by name or
        by file descriptor. As in 'get_casn_file', if 'name' is non-null, it  is
        taken  to be the name of a file to be opened, otherwise 'fildes' is used
        as the file descriptor for a file that has been opened for writing, e.g.
        '1'  for standard output.  When using 'put_casn_file', remember the note
        above about encoding empty objects.  Also remember that members of a SET
        or  SET OF may be written to a file in a different order (as required by
        DER) from that in which they appeared in memory.  This can be  confusing
        when  debugging.  It also means that, if a file is written and then read
        back, the indices to a SET OF may change!

        Sometimes it may  be  useful  for  debugging  purposes  to  inspect  the
        contents of a decoded ASN.1 stream.  The 'dump_casn' function translates
        the contents of such an object into more  legible  form  in  the  buffer
        specified  by  'to'.   The  'dump_size'  function tells how big a buffer
        'dump_casn' will need.  The format of the data returned  by  'dump_casn'
        looks like this, using the example of the Body object:

            seq seq int 0x01
                    enu 0x03
                set app+0x20
                        seq pri+0x20 /* etc. for upper arm */
                            pri+0x21 /* etc. for forearm */
                            pri+0x22
                                seq ctx+0x00
                                            0x03F8
                    app+0x21         /* etc for right arm like left */
                seq                  /* whatever trunk has */
                set seq ctx+0x20     /* etc. for thigh */
                        ctx+0x21     /* etc for shin */
                        ctx+0x22     /* etc. for foot */

        where the comments within '/* */' are replaced by  the  details  of  the
        object.   The  levels  of  the  ASN.1  definition  are  indicated by the
        indenting.  The abbreviations used are as follows:


Apr 20 2006                       14

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


                Abbreviation    ASN.1 Name
                    app             Application-specific*
                    bit             BIT STRING
                    boo             BOOLEAN
                    ctx             Context-specific*
                    enu             ENUMERATED
                    ext             EXTERNAL
                    gen             GeneralizedTime
                    gns             GeneralString
                    grs             GraphicString
                    ia5             IA5String
                    int             INTEGER
                    nul             NULL
                    num             NumericString
                    obd             ObjectDescriptor
                    obj             OBJECT IDENTIFIER
                    oct             OCTET STRING
                    pri             Private*
                    prt             PrintableString
                    rea             REAL
                    seq             SEQUENCE or SEQUENCE OF
                    set             SET or SET OF
                    t61             TeletexString (T61String)
                    utc             UTCTime
                    vst             VisibleString
                    vtx             VideotexString

        The starred items are always followed by '+0x' and a hex number.  If the
        most  significant  nibble  of  the  hex  number  has the 2 bit set (e.g.
        'app+0x21' above), the item is constructed, otherwise  it  is  primitive
        (e.g. 'ctx+0x00' above).

    Pointer Objects

        A pointer object,  introduced  to  permit  'nesting',  as  explained  in
        casn_gen(1), requires special addressing.  It uses a member of the basic
        'struct casn' called 'ptr' which forms a linked list.  This member  must
        be used with care.  If a pointer is defined, as in

            A ::= SEQUENCE
                {
                num   INTEGER,
                next  *A
                }

        and an object is defined as

            struct A a;

        then one could do

            struct casn *casnp = a.next.self.ptr;
            read_casn_num(&((struct A *)casnp)->num, (long *)&val);


Apr 20 2006                       15

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        or the second number in the chain could be addressed like this:

            ((struct A *)a.next.self.ptr)->num

        and one could read it in one step with

            read_casn_num(&((struct A *)a.next.self.ptr)->num, &val)

        The former method is preferable, since it allows checking to see if  the
        'ptr'  item  is null, thus avoiding a core dump.  Note that the compiler
        requires the word 'self' to reach the 'ptr' item.

        Pointer objects may be linked.  For example, if another object had  been
        defined as

            A aa;

        then the two could be linked with

            a.next.self.ptr = (struct casn *)&aa;

        In this case object 'aa' will be deleted when 'a' is.

        NOTE: Be careful not to assign an object's address to a  pointer  object
        which  is  an  undefined  member of a DEFINED BY, because any subsequent
        writing to the defining  object  will  clear  the  pointer  and  produce
        possible segmentation violation errors.

        Great care is required in addressing objects where there is a SET OF  or
        SEQUENCE OF pointers.  For example, if the specification read:

            H ::= SET OF *J

            J ::= SEQUENCE OF INTEGER

        then one could do:

            H h;
            J jj;
            struct casn *casnp;

            i = num_items(&h.self);
            inject_casn(&h.self, 0);
            member_casn(&h.self, 0)->ptr = &jj;
            casnp = &jj.self;
            i = num_items(casnp);
            casnp = member_casn(casnp, 0);
            inject_casn(casnp, 0);
            write_casn_num(member_casn(casnp, 0), (long)1);

        The use of intermediate 'struct casn *' pointers may make it  easier  to
        follow what is going on, although one could do:

            i = num_items(&h.self);

Apr 20 2006                       16

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


            inject_casn(&h.self, 0);
            member_casn(&h.self, 0)->ptr = &jj;
            i = num_items(member_casn(&jj.self, 0));
            inject_casn(member_casn(member_casn(&jj.self, 0), 0);
            write_casn_num(member_casn(member_casn(&jj.self, 0), 0), (long)1);

   << NEED TEXT: There should be a warning about clear_casn()
   destroying the choice state of the DEFINED BY, which can only be
   remedied by rewriting the definer. >>


    Addressing in a DEFINED BY

        The members of a DEFINED BY object are addressed using the names in  the
        defining table.  For example, if the ASN.1 has:

            XXX ::= SEQUENCE {
                a   INTEGER TABLE Table,
                b   ANY DEFINED BY a}

            Table ::= TABLE {
                c   INTEGER,
                d   OCTET STRING }

        and if the C declares:

            XXX xxx;

        then the members of 'xxx.b' are the  INTEGER  'xxx.b.c'  and  the  OCTET
        STRING 'xxx.b.d'.  This is covered in greater detail in Appendix A.


    Synthetic Names

        The latest ASN.1 specifications forbid 'absent' class names, such as  in
        'body.legs',  but  casn_gen(1)  accepts them for backward compatibility.
        This means it has to generate synthetic names to fill in for the missing
        ones.   Whenever  the 'casn_gen' program finds an item such as 'legs' in
        'Body' in Figure 1, it has to make up a synthetic name, because no class
        name is given.  In that case it concatenates the item name, 'legs', with
        the word 'In' and the classname, 'Body' to make  up  a  class  name  and
        capitalizes  the  first  letter, producing 'LegsInBody'.  Ordinarily the
        programmer need not worry  about  these  names,  since  one  can  access
        members  as  'body.legs.member()'.  If one defines a pointer, however, a
        synthetic name may be needed, e.g.

            LegsInBody *legp = body.legs.member(0);

        could be declared and used as

            read_casn(legp->foot, to)

        Reference to either the header file or the source code file produced  by
        casn_gen is the easiest way to find out what these names are.




Apr 20 2006                       17

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 



    Constraint Functions

        As  described  in  the  instructions  for  casn_gen(1),  certain   ASN.1
        definitions produce a definition of a member constraint function without
        a declaration of it, whereas some others produce both a definition and a
        declaration.  In the former case you must write the member function with
        the appropriate class name, e.g.

            int ConstraintInClassname()

        where "Classname" is replaced with the name of the class.  This function
        must  be  compiled  and  linked  with  all the other code, otherwise the
        linker will report it as undefined.  The constraint function must return
        a  one  if the object passes the constraint and a zero if it fails.  The
        constraint function must not call any of the encoding, reading or sizing
        functions  for  the  object  itself  because  these  functions  call the
        constraint function, causing infinite recursion.  Any attempt to use one
        of these functions will produce the run-time error message

            Error #25: Constraint calls forbidden function

        The functions 'decode_casn', 'encode_casn', 'size_casn' and 'vsize_casn'
        all  invoke  the  constraint  functions  at  the appropriate times, i.e.
        after decoding and before encoding or sizing.  Refer to the  Diagnostics
        section  below  for  information  on the effect of failing a constraint.
        That section also explains why  you  should  not  invoke  any  of  these
        functions for a member object within a constraint function.

DIAGNOSTICS

        In order to provide guidance as to what kind of error  was  encountered,
        various   error   conditions  and  messages  are  defined  in  the  file
        asn_error.h.  A function, 'void  casn_error(int,  char  *)'  prints  the
        error  message  on the standard output.  The meanings of the messages in
        that file are described in  Appendix  B.   The  user  may  replace  this
        function  with  another of the same name if standard error output is not
        desired.  The 'int' parameter of the function is the  error  number  and
        the  'char  *'  parameter  is  the  explanatory  message  as  defined in
        asn_error.h.

        When decoding or writing, the offset of the offending byte is sufficient
        to  tell where the problem lies, but when encoding or reading the stream
        will not have been completely encoded when  the  error  is  found.   For
        assistance in those cases where any form of encode, read, size, or vsize
        function returns an error, there is a global structure:

            struct casn_err_struct
                {
                int errnum;
                char *asn_map_string;
                struct casn *casnp;
                }i casn_err_struct;


Apr 20 2006                       18

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        to help in finding the source  of  the  error.   The  contents  of  this
        structure  are cleared at the start of any function that may require it.
        Whenever   an   error   is   detected,   the   character   array   named
        'asn_map_string' is filled in with a series of numbers separated by dots
        to indicate the point at  which  the  error  occurred.   Each  character
        represents  an ordinal number to tell which member of a structure was in
        error, i.e. '1' means the first, '2' the second, etc.  For  example  the
        string  '1.2.3'  indicates that the problem was encountered in the third
        element of the second element in the first element of  the  object  from
        which the call came.  If

            size_casn(&body.self)

        returns an error and this string  is  '2.1.3',  then  the  error  is  in
        'body.arms.left.hand.'

        In addition, when any such error is encountered, the error code  is  put
        into 'errnum' and the address of the object where the error was found is
        put into 'casnp'.

        If a constraint fails during encoding, sizing or writing, it is reported
        in  the  same  way  as any other error, but if a constraint fails during
        decoding, and there is no other error, the decoding continues,  and  the
        constraint  failure is reported by an automatic invocation of the 'size'
        function.  (The reason for the difference is that one usually  wants  to
        be  able  to  decode  an  incoming  message  unless  it is syntactically
        impossible to do so.)  The  negative  value  returned  by  a  constraint
        failure points just after the tag of the constraint's object.



























Apr 20 2006                       19

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


            Body ::= SEQUENCE {
                head        [0] Head,
                arms        [1] Arms,
                trunk       [2] Trunk,
                legs        [3] SET OF Leg }

            Head ::= SEQUENCE {
                hair        Hair,
                eyes        SET OF Eye}

            Hair ::= CHOICE {
                black   [1] INTEGER,
                blonde  [2] INTEGER,
                brown   [3] INTEGER,
                white   [5] INTEGER,
                other   [6] INTEGER,
                none    [0] BOOLEAN }

            Eye ::= ENUMERATED  {
                blue    (0),
                brown   (1),
                green   (2),
                black   (3),
                other   (10)}

            Arms ::= SET {
                left        [APPLICATION 0] Arm OPTIONAL,
                right       [APPLICATION 1] Arm OPTIONAL }

            Arm ::= SEQUENCE {
                upperarm    [PRIVATE 0] UpperArm,
                forearm     [PRIVATE 1] Forearm,
                hand        [PRIVATE 2] Hand }

            Hand ::= SEQUENCE {
                fingers     [0] Fingers IMPLICIT,
                palm        [1] Palm }

            Fingers ::= BIT STRING {
                thumb   (0),
                fore    (1),
                index   (2),
                ring    (3),
                little  (4) }

            Leg ::= SEQUENCE {
                thigh   [0] Thigh,
                shin    [1] Shin,
                foot    [2] Foot}

            Figure 1 - Sample ASN.1 Specification




Apr 20 2006                       20

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


          Appendix A - Operations With CHOICEs and DEFINED BY Objects

    Decoding any stream to an object (or encoding a stream from an object) which
contains a DEFINED BY object is completely  transparent and automatic.  Reading
and writing such objects requires a little explanation.  The rules are defined
to parallel those for a CHOICE as much as possible, because a DEFINED BY object
can be thought of as a choice in which the decision has been previously
selected.

    Objects which are defined as DEFINED BY using the TABLE extension of ASN.1
(as defined in casn_gen(1)) have four possible forms: ANY DEFINED BY, a tagged
ANY DEFINED BY, a DEFINED BY with something other than ANY, and a tagged DEFINED
BY with something other than an ANY.  For example:

    X ::= SEQUENCE
        {
        a       INTEGER TABLE ATable,
        b       CHOICE
                    {
                    i   INTEGER,
                    j   PrintableString
                    },
        c       ANY DEFINED BY a,
        d   [0] EXPLICIT ANY DEFINED BY a,
        e       OCTET STRING DEFINED BY a,
        f       BOOLEAN DEFINED BY a
        g   [1] OCTET STRING DEFINED BY a
        }

    ATable ::= TABLE {
        y  1   INTEGER PrintableString TeletexString FALSE Whatnot,
        z  2   BIT STRING BOOLEAN OCTET STRING TRUE Thing,
        any 0xFFFF  ANY ANY ANY FALSE }

    Whatnot ::= SEQUENCE OF INTEGER

    Thing ::= SEQUENCE OF PrintableString


    The rules for a CHOICE, such as object 'x.b', allow you to address the
contents at either of two levels for decoding, encoding or reading, but only at
the lower level for writing, i.e.

        x.b.i.decode_casn(buf)        or      x.b.decode_casn(buf)
        x.b.i.encode_casn(buf)        or      x.b.encode_casn(buf)
        x.b.i.read_casn(buf)          or      x.b.read_casn(buf)
        x.b.i.write_casn(buf, lth)

The decoding and encoding operations include the tag and length of the object,
whereas the reading and writing functions cover only the contents of the object.
The library functions for decoding, encoding and reading are 'smart' enough to
determine which lower level item is intended.  The ability to address at the
upper level is, therefore, provided as a convenience to the programmer.  Since
the contents of 'buf' for the writing operation do not include the tag, however,

Apr 20 2006                       21

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


the choice must be made by the programmer by addressing the lower level
explicitly.

    Looking at the DEFINED BY items, suppose the C declares:

    X x;

If object 'x.a' has been filled in with the value 1 so as to select item 'y' in
'x.c', 'x.d', 'x.e', x.f and x.g, then objects 'x.c.y', x.c.y', 'x.e.y', x.f.y
and x.g.y are marked as chosen.

    The rules for DEFINED BY are similar to thoose for a CHOICE but differ in
the case of a DEFINED BY with other than ANY.  They are summarized in this
table:

    Addressed | --------------- Operates on --------------------------
    Object    | Tag, length and Contents of |         Contents of
              | Decode      | Encode        |    Read     |     Write
              |             |               |             |
    x.b       |   x.b.i     |   x.b.i       |   x.b.i     |    N/A
    x.b.i     |   x.b.i     |   x.b.i       |   x.b.i     |   x.b.i
    x.c       |   x.c.y     |   x.c.y       |   x.c.y     |   x.c.y
    x.c.y     |   x.c.y     |   x.c.y       |   x.c.y     |   x.c.y
    x.d       |   x.d.y     |   x.d.y       |   x.d.y     |   x.d.y
    x.d.y     |   x.d.y     |   x.d.y       |   x.d.y     |   x.d.y
    x.e       |   x.e       |   x.e         |   x.e       |   x.e
    x.e.y     |   x.e.y     |   x.e.y       |   x.e.y     |   x.e.y
    x.f       |   x.f       |   x.f         |   x.f       |   x.f
    x.f.y     |   N/A       |   N/A         |   N/A       |   N/A
    x.g       |   x.g       |   x.g         |   x.g       |   x.g
    x.g.y     |   x.g.y     |   x.g.y       |   x.g.y     |   x.g.y

Note that the results for a non-ANY DEFINED BY are different at the two levels.
This is because an additional level of tagging has been introduced in the
definition.  Reading 'x.e' returns the contents of the OCTET STRING, whereas
reading 'x.e.y' returns the contents of the TeletexString.  Encoding 'x.e'
returns the entire OCTET STRING, whereas encoding 'x.e.y' encodes the
TeletexString.  Reading 'x.e' is thus the same as encoding 'x.e.y'.  Doing any
operation on 'x.f.y' is inappropriate and is detected as an error.

    The cases of 'x.d' and 'x.g' may require special treatment if you are trying
to fill in this item from an object which does not have the context-specific
tag.  If you try to encode and decode into 'x.d', there will be an error because
the tags do not match.  If you encode and decode into 'x.d.y' or 'x.d.z', or
'x.d.any', that will work correctly, but it requires knowing which item was
selected.  On the other hand, an attempt to read and write the contents to 'x.d'
will work correctly for the first two items in the table, but will fail to set
the tag for the catch-all item.  If you wish to write code which is independent
of the table choice, create a dummy object like this:

        DummyObj ::= [0] CHOICE {
            only   ANY }

and then decode the object into 'dummyObj.only', encode that, and decode it into

Apr 20 2006                       22

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


'x.d'.  Fortunately, ANY DEFINED BYs are rarely tagged like this.






















































Apr 20 2006                       23

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


                          Appendix B - Error Messages
     The error conditions detected in the library functions and the messages  in
'asn_error.h' have the following meanings:

    1. Stream doesn't match object

        The stream being decoded doesn't match the pattern of tags  defined  for
        the object.

    2. Error getting memory

        An error occurred when a function called  'malloc'  (or  equivalent)  to
        obtain memory, usually during a decoding or writing operation.

    3. Error in casn_gen's code

        The ASN.1 compiler produced improper code.   Currently  the  only  error
        detected is the sub-definition of any universal primitive other than BIT
        STRING, INTEGER or ENUMERATED.

    4. Can't write to a CHOICE

        An attempt was made to write to a CHOICE which was other than a  numeric
        string,  printable  string  or  teletex  string  (see  error  20 below).
        Selection of a member of a CHOICE requires knowledge of the  tag,  which
        is  not  present  in  the  'write' operation.  The desired member of the
        CHOICE  must  be  explicitly  addressed,  unless  it  is  one   of   the
        aforementioned strings.  This is a common mistake.

    5. Tags not consistent in SET/SEQ OF

        A SET OF or SEQUENCE OF was encountered in which not all the members had
        the  same tag.  The C compiler should detect this, unless a variable has
        been improperly cast.

    6. Mandatory field is not filled in

        A library function encountered an empty field  which  is  not  OPTIONAL.
        This  may occur when decoding, writing, reading or encoding, Note that a
        SET OF or a SEQUENCE OF may be empty  if  its  minimum  size  is  either
        undefined or defined as zero.  This is a common error.

    7. Not a SET/SEQ OF

        An attempt was made to insert or remove an object which was not a member
        of a SET OF or a SEQUENCE OF.  The C compiler should detect this, unless
        a variable has been improperly cast.

    8. Out of bounds in SET/SEQ OF

        An attempt was made to address beyond the  bounds  of  a  SET  OF  or  a
        SEQUENCE OF.

    9. Source is empty

Apr 20 2006                       24

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        An attempt was made to copy from an object which had not been filled  in
        at all.

    10. Definer not in table

        An attempt was made to write a value to an object for which a  TABLE  is
        defined, and the value being written was not defined in the table.  This
        may also occur during a decoding operation.

    11. DEFINED BY not defined yet

        An attempt was made to write to a DEFINED BY object before the  defining
        object had been filled in.

    12. Size out of bounds

        A writing or decoding operation encountered  a  value  or  stream  which
        exceeded  the  minimum  or  maximum  limits defined for the object being
        filled in.

    13. Invalid operation for this type

        The functions 'read_casn_num()' or 'write_casn_num()' were called for an
        object  which  was  not BOOLEAN, INTEGER or ENUMERATED, or the functions
        'read_casn_time()' or 'write_casn_time()'  were  called  for  an  object
        which  was not UTCTime or GeneralizedTime.  Also occurs with any attempt
        to write to a NULL object with non-zero length.

    14. Invalid time field

        A decoding or writing  operation  encountered  a  UTCTime  object  or  a
        GeneralizedTime object containing an invalid value.

    15. Improper ASN.1 string

        A decoding function found an ASN.1 encoding error.  Currently this  only
        occurs  for  primitive items which are encoded with indefinite length or
        for INTEGERs with redundant leading bytes.

    16, Null pointer passed to AsnObj member function

        A null pointer was passed to a library function.

    17. Can't write to a NONE

        An attempt was made to 'write' to an object in a DEFINED  BY  for  which
        the  table defined no object.  Also occurs if a 'decode' encounters such
        a situation.

    18. Trying to write an undefined value

        Not used.

    19. Character string not valid for any of CHOICE

Apr 20 2006                       25

CASN Functions (3)         ASN.1 C LIBRARY FUNCTIONS   CASN Functions (3) 


        This indicates that a 'write' to a CHOICE of different character strings
        tried  to  write  a  character which did not satisfy any of the choices.
        For example, if a CHOICE is a NumericString or a  PrintableString,  then
        writing  an  alphabetic  string  will  choose  the  PrintableString, but
        writing a string containing an ampersand will produce this error.   (See
        also error 4 above.)

    20. Invalid character at [-(value returned)]

        An attempt was made  to  'decode'  or  to  'write'  a  NumericString,  a
        PrintableString  or  a  TeletexString  with  a string which contained an
        invalid character.  The value returned is the negative of the offset  to
        the offending character in the string.

    21. Error trying to find DEFINED BY

        At the time when a definer was written, the  code  could  not  find  the
        specified  defined  item.   Check  the ASN.1 specification and the TABLE
        definition.

    22. Invalid length field

        During decoding a length field was encountered which specified that  the
        length  number  was greater than 4 bytes long.  This may be caused by an
        earlier error which threw off the determination  of  tags,  lengths  and
        contents.   Decode  returns  the negative of the offset to the offending
        byte.  If that byte is not the start of a length field, the problem lies
        earlier in the ASN.1 stream.

    23. Didn't use all of file

        In a call to get_file(), the ASN.1 object did  not  occupy  all  of  the
        file.  Probably there is extra material after the ASN.1 object.






















Apr 20 2006                       26
